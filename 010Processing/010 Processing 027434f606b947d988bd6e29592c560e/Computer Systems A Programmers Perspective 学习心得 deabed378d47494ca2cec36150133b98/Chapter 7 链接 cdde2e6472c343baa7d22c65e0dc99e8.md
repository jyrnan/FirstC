# Chapter 7 链接

## 7.2 静态链接

像 Linux LD 程序这样的静态链接器 (static linker) 以 一组可重 定位目标文件和命令行 参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。

输入的可重定位目标文件由各种不同的代码和数据节 (**section)**组成，每一节都是一个连续的字节序列。

**链接器必须完成两个主要任务:**

- **符号解析 (symbol resolution) 。**目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量(即 C 语 言 中任何以 static 属性 声明的变量)。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。
- **重定位 (relocation) 。**编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通
过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置 。 链接器使用汇编器产生的重定位条目 (relocation entry)的详细指令，不 加甄别地执行这样的重定位 。

> 链接器的一些基本事实:**目标文件纯粹是字节块的集合**。这些块中，有些包含程序代码有些包含程序数据，而其他的则包含引导链接器和加载器的数据结构 。链接器将这些块连接起来，确定被连接块的运行时位 置，并且修改代码和数据块中的各种位置。
> 

## 7.3 目标文件

**三种形式：**

- 可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件 。
- 可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行 。
- 共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态加载进内存并链接。

## 7.4 可重定位目标文件

![Untitled](Chapter%207%20%E9%93%BE%E6%8E%A5%20cdde2e6472c343baa7d22c65e0dc99e8/Untitled.png)

ELF 头 （ELF header) 以一个16字节的序列开始，这个序列描述了生成该文件
的系统的字的大小和字节顺序。等等……**节头部表 (section header table) 的文件偏移**。

不同节的位置和大小是由**节头部表描述**的，其中目标文件中每个节都有一个固 定大小的条目 (entry) 。

一个典型的 ELF 可重定位目标文件包含下面几个节:

- .text: 已编译程序的机器代码。
- .rodata: 只读数据
- .data: 已初始化的全局和静态 C 变量
    
    > 局部 C 变量在运行时被保存在栈中，既不出 现在 .da七a 节中，也不出现在 .bss 节中。
    > 
- bss: 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在
目标文件中这个节不占据实际的空间，它仅仅是 一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率:在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。
- syrntab: 一个符号表，它存放在程序中定义和引用的函数和全局变掀的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每
个可重定位目标文件在 .syrn七ab 中都有一张符号表(除非程序员特意用 STRIP 命令去掉它)。然而，和编译器中的符号表不同，. syrntab 符号表不包含局部变量的条目。

## 7.6 符号解析

链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的 一个确定的符号定义关联起来

### 7.6.2 与静态库链接

所有的编译系统都提供一种机制，将所有相关的目标 模块打包成为一个单独的文件，称为静态库 (static library), 它可以用做链接器的输入。

在 Linux 系统中，静态库以一种称为存档 (archive)的特殊文件格式存放在磁盘中。存 档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文
件的大小和位置 。存档文件名由后缀 .a 标识。

<aside>
💡 各种.o文件会汇总成一个.a文件，然后连接器链接的时候从.a文件中选择需要的.o文件来链接—by myself

</aside>

![Untitled](Chapter%207%20%E9%93%BE%E6%8E%A5%20cdde2e6472c343baa7d22c65e0dc99e8/Untitled%201.png)

## 7.7 重定位

一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义 (即它的一个输入目标模块中的一个符号表条目)关联起来。此时，链接器就知道它的输入 目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤 中，将合并输入模块，并为每个符号分配运行时地址。

重定位由两步组成:

- 重定位节和符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的 新的聚合节。
- 重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的 引用，使得它们指向正确的运行时地址。

## 7.8 可执行目标文件

![Untitled](Chapter%207%20%E9%93%BE%E6%8E%A5%20cdde2e6472c343baa7d22c65e0dc99e8/Untitled%202.png)

ELF 头描述文件的总体格 它还包括程序的入口点 (entry point ) , 也就是当程 序 运行 时要 执 行 的第一条指令的地 址 。 .text、 .rodata 和 .da七a 节与可 重 定 位 目标文件中的节 是 相似的，除了这些节巳经被 重定位到它们最终的运行时内存地址以外。.init节定义了一个小函数，叫做.init,程序式 。的初始化代码会调用它 。

## 7.9 加载可执行目标文件

![Untitled](Chapter%207%20%E9%93%BE%E6%8E%A5%20cdde2e6472c343baa7d22c65e0dc99e8/Untitled%203.png)

Linux 系统 中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间。当 shell 运行一个 程序时，父 shell 进程生成一个子进程，它是父进程的一个复制。子进程通过 execve 系 统调用启动加载器。加栽器删除子进程现有的虚拟内存段，并创建一组新的代码、数 据、堆和栈段。新的栈和堆段被初始化为零 。 通过将虚拟地址空间中的页映射到可执行文件的页大小的片 (chunk), 新的代码和数据段袚初始化为可执行文件的内容。最后， 加载器跳转到 _start地址，它最终会调用应用程序的 main 函数。除了一些头部息，在 加栽过程中没有任何从磁盘到内存的数据复制 。 直到 CPU 引用一个被映射的虚拟页时才 会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。

## 7.10 动态链接共享库

> **静态库仍然有一些明显的缺点。
静态库和所有的软件一样，需要定期维护和更新。**如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式地将他们的程序与更新了的库重新链接。
另一个问题是几乎每个 C 程序都使用标准 I/0 函数，比如 printf 和 scanf。在运行
时，**这些函数的代码会被复制到每个运行进程的文本段中** 。 在一个运行上百个进程的典型 系统上，这将是对稀缺的内存系统资源的极大浪费。
> 

**共享库 (shared Iibrary)**是致力千解决静态库缺陷的一个现代创新产物。共享库是一个 目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接 起来 。这个过程称为动态链接 (dynamic linking) , 是由一个叫做动态链接器 (dynamic linker) 的程序来执行的 。

## 7.13 打桩机制

Linux 链接器支持一个很强大的技术，称为库打桩 (library interpositioning), 它允许 你截获对共享库函数的调用，取而代之执行自己的代码。使用打桩机制，你可以追踪对某 个特殊库函数的调用次数，验证和追踪它的输入和输出值，或者甚至把它替换成一个完全 不同的实现。

下面是它的基本思想:给定 一个需要打桩的目标函数，创建一个包装函数，它的原型与标函数完全一样。使用某种特殊的打桩机制，你就可以欺骗系统调用包装函数而不是目标函数了。包装函数通常会执行它自己的逻辑，然后调用目标函数，再将目标函数的返回值传递给调用者。

打桩可以发生在编译时、链接时或当程序被加载和执行的运行时。

## 小结

链接可以在编译时由静态编译器来完成 ，也可以在加载时和运行时由动态链接器来完成。

- 链接器处理称为目标文件的二进制文件，它有 3 种不同的形式:**可重定位**的、**可执行**的和**共 享的**。可重定位的目标文件由静态链接器合并成一个可执行的目标文件，它可以加载到内存中并执行。 共享目标文件(共享库)是在运行时由动态链接器链接和加载的，或者隐含地在调用程序被加载和开始执行时，或者根据需要在程序调用 dlopen库的函数时。
- 链接器的两个主要任务是**符号解析**和**重定位** ， 符号解析将目标文件中的每个全局符号都绑定到一个唯一的 定义，而重定位确定每个符号的最终内存地址，并修改对那些目标的引用。

静态链接器是由像 GCC这样的编译驱动程序调用的。它们将多个可重定位目标文件合并成 一个单独的可执行目标文件。多个目标文件可以定义相同的符号，而链接器用来悄悄地解析这些多重定义的规则 可能在用户程序中引 入微妙的错误 。

多个目标文件可以被连接到一个单独的静态库中。链接器用库来解析其他目标模块中的符号引用 。 许多链接器通过从左到右的顺 序扫描来解析符号引用，这 是另一个引起令人迷惑的链接时错误的来源 。

**加载器**将可执行文件的内容映射到内存，并运行这个程序。链接器还可能生成部分链接的可执行目标文件，这样的文件中有对定义在共享库中的例程和数据的未解析的引用。在加载时，加载器将部分链接的可执行文件映射到内存，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链接任务。
被编译为位置**无关代码**的共享库可以加载到任 何地方，也可以在 运行时被多个进程享。为了加载、 链接和访问共享库的函数和数据，应用程序也可以在运行时使用动态链接器。